use clap::{App, Arg, AppSettings};

pub fn gen_app() -> App<'static> {
    let app = App::new("NotesManager")
        .setting(AppSettings::ArgRequiredElseHelp)
        .version(env!("CARGO_PKG_VERSION"))
        .subcommand(App::new("list")
            .about("Lists all available notes")
            .arg(Arg::new("uuid")
                .short('u')
                .long("uuid")
                .about("Prints additional uuid")
                .required(false)
            )
            .arg(Arg::new("names")
                .short('n')
                .long("names")
                .about("Prints names only")
                .required(false)
            )
            .arg(Arg::new("deleted")
                .short('d')
                .long("deleted")
                .about("Prints deleted notes only")
                .required(false)
            )
        )
        .about("Interface for interacting with Apple Notes on Linux")
        .subcommand(App::new("edit")
            .about("Edits an existing note")
            .arg(Arg::new("path")
                .required(true)
                .takes_value(true)
                .about("Subject or UUID of the note that should be edited")
            )
        )
        .subcommand(App::new("sync")
            .about("Syncs local with remote notes and vice versa")
            .arg(Arg::new("dry-run")
                .required(false)
                .short('n')
                .takes_value(false)
                .about("Dry run")
            )
        )
        .subcommand(App::new("delete")
            .about("Flags a note as deleted")
            .arg(Arg::new("path")
                .required(true)
                .takes_value(true)
                .about("Subject or UUID of the note that should be deleted")
            )
        )
        .subcommand(App::new("undelete")
            .about("Removes deletion flag")
            .arg(Arg::new("path")
                .required(true)
                .takes_value(true)
                .about("Subject or UUID of the note")
            )
        )
        .subcommand(App::new("merge")
            .about("Merges unmerged Note")
            .arg(Arg::new("path")
                .required(true)
                .takes_value(true)
                .about("Subject or UUID of the note that should be merged")
            )
        )
        .subcommand(App::new("print")
            .about("Prints note content")
            .arg(Arg::new("path")
                .required(true)
                .takes_value(true)
                .about("Subject or UUID of the note that should be printed")
            )
        )
        .subcommand(App::new("backup")
            .about("Duplicates current note tree on the imap server")
        )
        .subcommand(App::new("move")
            .about("Moves note to another folder")
            .arg(Arg::new("note")
                .about("title or uuid of the note")
                .required(true)
                .takes_value(true))
            .arg(Arg::new("folder")
                .about("Moves note to another folder")
                .required(true)
                .takes_value(true))
        )
        .subcommand(App::new("new")
            .about("Creates a new note")
            .arg(Arg::new("folder")
                .short('f')
                .long("folder")
                .about("Specifies the subfolder where the note should be put in. Uses default folder, if not used")
                .required(false)
                .takes_value(true)
            )
            .arg(Arg::new("title")
                .required(true)
                .takes_value(true)
                .about("Title of the new note")
            )
        );
    app
}
